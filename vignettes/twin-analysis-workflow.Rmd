---
title: "Twin analysis vignette"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{twin-analysis-workflow}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


# Introduction

Hi!

This vignette has a purpose to illustrate the functionality of `TwinAnalysis` package for statistical analysis of twin data. 

What this package can do:

1. Define the most used twin models in one line of code. All models include the output tables with parameters that we usually report.

2. Define the cross-lag ACE model.

3. Perform routine operations, such as computing descriptive statistics or twin correlations.

What this package cannot do:

1. The models with categorical outcome variables currently are not supported.

2. The package cannot choose the model or fix the model that does not fit the data.

3. The package cannot check distributions, remove outliers or reshape data tables. All this can be done by means of standard functionality of R.

This package entirely relies on functionality of `OpenMx`, a package for structural equation modeling. `OpenMx` is widely used for twin analysis.

`TwinAnalysis` also depends on its companion `mlth.data.frame` package for output tables.

This vignette assumes that the reader is familiar with principles of twin analysis and has an idea of `OpenMx`. Also, in this vignette I use [`%>%` pipe operator](https://www.datacamp.com/community/tutorials/pipe-r-tutorial) from `dplyr`. 

# Loading packages and the data

```{r setup}
library(dplyr)
library(mlth.data.frame)
library(OpenMx)
library(TwinAnalysis)
```

I will use the dataset of twin from `OpenMx`. This is an Australian twin data on height (`ht1/2`), weight (`wt1/2`) and BMI (`bmi1/2`). There are two cohorts of twins: younger (`zyg %in% 1:5`) and older (`zyg %in% 6:10`). Details in `?twinData`.

```{r load_data}
data(twinData)

head(twinData)
```

# Pre-processing twin data

Pre-processing of the data may include many steps, such as:

  - computing test scores,
  - excluding non-valid data values,
  - checking distributions,
  - removing outliers,
  - transforming variables,
  - performing factor analysis,

...and they all are not covered in this vignette.

There are two formats of the tables with twin data:

 - *wide* format where a row of the table stands for one twin pair,
 - *long* format where a row of the table is a single twin, the twins are matched by family ID. 
 
Most functions from `TwinAnalysis` operate with the data in *wide* format. It is assumed that the  variables that differ between the twins in a twin pair are named as `X1` and `X2`. `X1` is trait `X` in the first twin and `X2` is trait `X` in the second twin. <em>Mind that there is no separator between variable name and the suffix `1/2`.</em>

Below is an example of reshaping wide table `twinData` to long table `longData` and back.

```{r}
# From wide to long
longData <- twinData %>%
  reshape(direction = 'long',
          varying = c('wt1', 'wt1', 'ht1', 'ht2',       # The variables that vary 
                      'htwt1', 'htwt2', 'bmi1', 'bmi2', # within a twin pair
                      'age1', 'age2'), 
          sep = '') #                 <- A separator between variable name and suffix

head(longData)

# Back from long to wide
longData %>%
  reshape(direction = 'wide',
          v.names = c('wt', 'ht', 'htwt', # The variables that vary within a twin pair 
                      'bmi', 'age'),      
          idvar = 'fam',             # Unique identifier of twin pair
          timevar = 'time',          # Twin number (identifier of twin within pair)
          sep = '') %>%              # Optional: a separator, default '.'
  head
```

!!!

Zygosity is a key variable for twin analysis as it labels MZ and DZ twins. A twin pair with no zygosity is almost useless. Here, `zygosity` labels both zygosity and sex. I use this information to create two separate variables for zygosity and sex.

```{r}
twinData$zyg <- twinData$zygosity %>%
  as.character %>%
  sapply(switch,
         MZFF = 'MZ',
         MZMM = 'MZ',
         DZFF = 'DZss',     # Same-sex DZ pairs
         DZMM = 'DZss',
         DZOS = 'DZos') %>% # Opposite-sex DZ pairs
  factor(levels = c('MZ', 'DZss', 'DZos')) # This is to keep the order of levels

twinData$sex1 <- twinData$zygosity %>%
  as.character %>%
  sapply(switch,
         MZFF = 'Female',
         MZMM = 'Male',
         DZFF = 'Female',     
         DZMM = 'Male',
         DZOS = 'Female')    # First twin in opposite-sex pair is female

twinData$sex2 <- twinData$zygosity %>%
  as.character %>%
  sapply(switch,
         MZFF = 'Female',
         MZMM = 'Male',
         DZFF = 'Female',     
         DZMM = 'Male',
         DZOS = 'Male')    # Second twin in opposite-sex pair is male

# There are many alternative ways to do the same thing
# I also like to check whether the manipulations with the data
# did the right thing, like so:
table(twinData$zygosity, twinData$zyg)
table(twinData$zygosity, twinData$sex1)
table(twinData$zygosity, twinData$sex2)
```

Finally, for this analysis I will select only the younger cohort.

```{r}
# I usually don't omit the data from original datafames but make a copy
twinData2 <- twinData[twinData$cohort == 'younger', ]
```

# Twin descriptive statistics

Descriptive statistics are important for twin analysis because they help us to make sure that the data is OK and that the assumptions of twin model hold. If assumptions don't hold, the model will likely have poor fit meaning that we cannot be sure that it really captures the reality we study.

One of the major (mathematical) assumptions is that the phenotype has the same scale in twins within twin pair and in zygosity groups. This means that means and variances shouldn't differ between twin 1 and twin 2 and across zygosity groups (MZ, DZ). Another mathematical assumptions concern twin similarity witnin the pair: $r_{MZ} > r_{DZ}$ and $2r_{DZ} < r_{MZ}$ (ACE model) or $r_{MZ}>2r_{DZ}$ and $4r_{DZ} > r_{MZ}$ (ADE model). We also may want to compare twin similarity in DZss and DZos pairs if we want to combine them into a single group.

The `TwinAnalysis` package provides functionality to compute descriptive statistics (means, SDs, twin correlations).

```{r}
get_univ_descriptives(twinData2, zyg = 'zyg',       # Actually any factor variable
                      vars = c('ht', 'wt', 'bmi')) # No suffix

# We can also compare DZss and DZos correlations to check if they differ
get_fisher_z(twinData2, zyg = 'zyg', 
             vars = c('ht', 'wt', 'bmi'), 
             compare = c('DZss', 'DZos'))
```

What catches the eye in this dataset is the difference between twin 1 and twin 2 in DZos group in height and weight. This is a natural result of twin 1 being female and twin 2 being male in this group. The twin similarity is lower in DZos pairs comparing to DZss pairs, also the result of sex differences in height and weight. Finally, $r_{MZ} > 2r_{DZ}$ for BMI which means that non-additive genetic effects may contribute to this phenotype and ADE model may be more appropriate.

For now, I ignore sex differences and exclude DZos pairs from the analysis by making a new zygosity variable.

```{r}
twinData2$zyg2 <- twinData2$zyg %>%
  as.character %>%
  sapply(switch, 
         MZ = 'MZ', 
         DZss = 'DZ', 
         DZos = NA) %>%
  factor(levels = c('MZ', 'DZ'))

twinData2 <- twinData2[!is.na(twinData2$zyg2), ]

get_univ_descriptives(twinData2, zyg = 'zyg2',
                      vars = c('ht', 'wt', 'bmi'))
```

# Univariate twin model

Now we are ready for a univariate twin analysis which is the simplest form of twin model.

Let's fit a univariate ACE model to BMI.

```{r}
# Define the model
bmi_univ <- univariate_ace(twinData2, zyg = 'zyg2', vars = 'bmi')

# Fit MxModel
bmi_univ <- mxRun(bmi_univ)

# OpenMx summary
summary(bmi_univ)

# Output tables
get_output_tables(bmi_univ)
```

`univariate_ace()` returns an MxModel object which means that you can apply all functions that OpenMx provide to treat the models, such as `mxRun()`, `mxTryHard()`, `summary()` and others. You also can access, add and remove the elements (`MxAlgebra`, `MxMatrix`, `MxConstraint`, `MxCI`, etc) from the model.

```{r}
bmi_univ

bmi_univ$expCovMZ

mxEval(expCovDZ, bmi_univ)

# Note that expected variances for MZs and DZs are exactly same, it's not a coincidence
```

In addition to the standard model structure, such as the parameter matrices, the algebra for expected covariance matrix, the observed data, `unvariate_ace()` (as well as the other functions from `TwinAnalysis` that define models) adds the algebra that computes indeces that we actually will use as main results. In particular, `univariate_ace()` returns the single otput table with percents of variability accounted for by A, C and E. The output tables are usually stored inside the model as `MxAlgebra`.

The function `get_output_tables()` retrieves the output tables from the model, append CIs (if available) and return them in ready-to-use form. The names of the tables that should be returned by `get_output_tables()` are stored as an `output_tables` option of the model. You can access and modify this option using `output_tables()`, `output_tables<-()` and `def_output_tables()`, although it's not what you do on the regular basis when using `TwinAnalysis`. 

Next, we have to assess model performance to find out whether it fits the data at all. `ref_models()` and `twin_ref_models()` each define the set of two reference models: Saturated and Independence. Saturated model assumes that all obseved variables may associate however they like meaning that it's the most relaxed and the less constrained model. Independence model assumes that all observed variables are independent. The fit of the model under assessment is somewhere in between Saturated model and Independence model. The difference between `ref_models()` and `twin_ref_models()` is that the later define the reference models that rely on the assumptions of twin model (equal means and variances).

```{r}
# bmi_univ and bmi_univ2 will be the same model with different reference models
bmi_univ2 <- bmi_univ 

ref_models(bmi_univ) <- twin_ref_models(bmi_univ, run = TRUE)
ref_models(bmi_univ2) <- ref_models(bmi_univ2)
bmi_univ2 <- run_ref_models(bmi_univ2)

fit_stats(bmi_univ)
fit_stats(bmi_univ2)
```

At the end, the `fit_stats()` function return the table with various fit statistics. When compared to the reference models tailored specifically to conform the assumptions, our univariate model exhibits perfect fit and has the same amount of degrees of freedom as Saturated model. In both cases the model has good fit according to BIC, TLI and RMSEA. When compared using chi-squared test (`diffLL`, `diffdf` and `p`), the model significantly differ from the most relaxed Saturated model ($p < 0.05$). To find out if this happened because of assumption violation, we can compare two Saturated models.

```{r}
mxCompare(ref_models(bmi_univ2)$Saturated,
          ref_models(bmi_univ)$Saturated)
```

The statistically significant difference between two Saturated models shows that there is assumption violation. It does not necessary mean that we have to throw away the model because when the number of participants is high, even the small differences in means or variances can be statistically significant. I usually look at all descriptive statistics, fit statistics and decide whether I trust the model or not. In this case I would leave the model as it is because CFI, TLI and RMSEA are good.

I usually have to fit univariate twin model for multiple phenotypic variables. For this I use loop and store the models in a list.

```{r}
univ_models <- list()

for (v in c('ht', 'wt', 'bmi')) {
  model <- univariate_ace(twinData2, zyg = 'zyg2', vars = v)
  model <- mxRun(model, intervals = TRUE)   # This time I evaluate CIs
  ref_models(model) <- ref_models(model)
  model <- run_ref_models(model)
  
  univ_models[[v]] <- model
}
```

Having the models in a list, I can iterate through the list to aggregate the output into the tables.

```{r}
# Estimates of genetic and environmental contributions
univ_models %>%
  lapply(get_output_tables) %>%
  lapply(`[[`, 'Variance_components') %>% # same as lapply(function(x) x[['Variance_components']])
  do.call(rbind, .)

univ_models %>%
  lapply(fit_stats) %>%
  do.call(rbind, .)
```

# Bivariate twin model

We apply a bivariate twin model to find out whether shared genetic or environmental factors might cause the measured correlation between two traits. More generally, we can build a structure of unobservable genetic and environmental effects and, assuming that this structure explain observable relationships, find most probable values of unobserved parameters.

If we want to apply a bivariate twin model to explore the relationship between height and weight, we will have 4-by-4 variance-covariance matrix. On this matrix we can distinguish within-twin and cross-twin variances-covariances.

```{r}
twin_cors <- get_cross_trait_cors(twinData2, zyg = 'zyg2',
                                  vars = c('ht', 'wt'))
twin_cors

# Within-twin variances-covariances
# Each table is diagonally symmetrical
twin_cors %>% 
  lapply(`[`, c('ht1', 'wt1'), c('ht1', 'wt1'))
twin_cors %>% 
  lapply(`[`, c('ht2', 'wt2'), c('ht2', 'wt2'))

# Cross-twin within-trait covariances
# Second set of tables is transposed first set of tables
twin_cors %>% 
  lapply(`[`, c('ht1', 'wt1'), c('ht2', 'wt2'))
twin_cors %>% 
  lapply(`[`, c('ht2', 'wt2'), c('ht1', 'wt1'))
```

Within-twin variances-covariances are like phenotypic relationships. These are variabilities of measured traits and relationships between the traits within person. Multivariate twin model assumes that these matrices are equal.

Cross-twin covariances can be within-trait (ht1-ht2) or cross-trait (ht1-wt2). We expect that correlation between ht1 and wt2 is equal to correlation between ht2 and wt1 (but only within zygosity groups).

Variances and covariances look fine, we can perform bivariate analysis.

```{r}
biv_model <- multivariate_ace(twinData2, zyg = 'zyg2',
                              vars = c('ht', 'wt'))
biv_model <- mxRun(biv_model)
```

It says that the optimizer failed to find optimal parameter values (status code RED). We then check model identification as OpenMx suggested.

```{r}
mxCheckIdentification(biv_model)
```

Now it says that we have problems with all main parameters: `a`, `c` and `e`. These are three lower triangular matrices that we multiply by themselves to obtain genetic and environmental variances-covariances (Cholesky approach). In this particular case I gonna fix non-shared environmental covariation (`e[2, 1]`) to zero because very rarely two traits correlate because of some person-specific experience. Also, the individual contribution of non-shared environment to height (estimated from univariate ACE) is low, that likely made the non-shared environmental correlarion between height and weight unidentifiable. If some factor does not contribute to individual differences in a trait, it cannot explain relationship between this trait and another trait.

```{r}
biv_model <- multivariate_ace(twinData2, zyg = 'zyg2',
                              vars = c('ht', 'wt'))
biv_model$e$values[2, 1] <- 0     # This might not be the best way to fix a parameter
biv_model$e$free[2, 1] <- FALSE

biv_model <- mxRun(biv_model)

# It works fine now

get_output_tables(biv_model)

ref_models(biv_model) <- ref_models(biv_model)
biv_model <- run_ref_models(biv_model)
fit_stats(biv_model)
```

Now it works fine. Note, this way of constraining environmental correlation will not work in case of more that two phenotypic variables. We can check that we successfully constrained non-shared environmental correlation by looking at the output (`All_correlations`, `E==0`). The model fit is fine considering very good CFI, TLI and RMSEA.

The bivariate twin model brings the following pieces of the output:
  - variance components - the contributions of genetic and environmental effects to individual differences in each phenotypic variable in the analysis,
  - genetic and environmental correlations, estimated phenotypic correlation and percent of phenotypic correlation accounted for by the overlap in genetic and environmental effects,
  - genetic, environmental and phenotypic correlations placed in separate tables.



# Notes:

  1. The models with cathegorical outcomes: different fit function and fit statistics may be needed
  2. In multivariate models we can achieve genetic and environmental correlations with opposite sign. This means that one factor will contribute to phenotypic relationship positively and another negatively. In this case we have to treat percents with caution. I use absolute value of correlations to compute percents.
  3. If the model has not been fit yet, get_output_tables() will throw error
